# Сервис управления рассылками сообщений, администрирования и получения статистики по ним


[1. Цель проекта](#title1) / 
[2. Шаблоны страниц](#title2) / 
[3. Модели](#title3) / 
[4. Админки](#title4) / 
[5. Формы](#title5) / 
[6. Контроллеры](#title6) / 
[7. Ограничение прав доступа](#title7) / 
[8. Менеджер команд](#title8) / 
[9. Сервисные функции (services.py)](#title9) / 
[10. Функционал рассылки по расписанию (scheduler.py)](#title10) / 
[11. Автозапуск планировщика (apps.py)](#title11) / 
[12. Вспомогательные функции (managers.py)](#title12) / 
[13. Установка проекта](#title13) / 
[14. Получение ключей .env](#title14) / 
[15. Описание файла .flake8](#title15) / 
[16. Описание файла mypy.ini](#title16) / 
[17. Описание директории Data](#title17) / 




# <a id="title1">1. Цель проекта</a>
Чтобы удержать текущих клиентов бизнеса, часто используются вспомогательные, или "прогревающие" рассылки для информирования и привлечения.

Необходимо создать веб-приложение на Django, которое позволяет пользователям управлять рассылками сообщений для клиентов. Приложение включает функциональность для создания, просмотра, редактирования и удаления рассылок, а также отправки сообщений по требованию.




# <a id="title2">2. Шаблоны html-страниц (templates)</a>

## _Приложение "app_mailing" (app_mailing/templates/):_

Реализованы следующие HTML-страницы:

1) `Шаблонные страницы`
   - ***base.html***: общий (базовый) шаблон для всех пользовательских страниц, который включает общие элементы страницы, такие как:
     - подключение всплывающих уведомлений для пользователей с информированием об успешной отправке различных форм (например, добавили нового клиента или удалили рассылку и так далее).
     - подключение подшаблона с меню (верхняя часть с навигацией).
     - подключение основного контента страницы.
     - подключение нижней части с футером (подвал).
     - подключение статичеcких файлов со стилями и скриптами Bootstrap.
     - инициализирование tooltip (и popover) в "mailing_list.html", чтоб для Получателей отображалось "количество" и "тултип с ФИО" (при наведении отображаю ФИО получателей).
   - ***menu.html***: подшаблон, в котором описано главное меню:
     - ссылки для всех пользовательских страниц (навигация между разделами магазина).
     - блок с кнопками аутентификации ("Регистрация", "Войти", "Выйти", "Редактировать профиль", "Изменить пароль") и логикой их отображения в зависимости от текущего состояния пользователя (авторизован или нет).


2) `Пользовательские страницы для "Управление клиентами"`
   - ***recipient_list.html***: страница для *отображения списка* Получателей в сервисе управления рассылками (модель данных **Recipient**).
     - Функционал страницы:
       - Переход на страницу добавления нового получателя.
       - Переход на страницу редактирования получателя.
       - Переход на страницу удаления получателя.
   - ***recipient_add_update.html***: страница для *добавления* нового или *обновления* существующего Получателя рассылки (модель данных **Recipient**).
     - Функционал страницы:
       - Добавить\Редактировать получателя.
       - Вернуться на страницу списка получателей.
   - ***recipient_delete.html***: страница для *удаления* Получателя рассылки (модель данных **Recipient**).
     - Функционал страницы:
       - Удаление получателя.
       - Вернуться на страницу списка получателей.


3) `Пользовательские страницы для "Управление сообщениями"`
   - ***message_list.html***: страница для *отображения списка* Сообщений в сервисе управления рассылками (модель данных **Message**).
     - Функционал страницы:
       - Переход на страницу добавления нового сообщения.
       - Переход на страницу редактирования сообщения.
       - Переход на страницу удаления сообщения.
   - ***message_add_update.html***: страница для *добавления* нового или *обновления* существующего Сообщения рассылки (модель данных **Message**).
     - Функционал страницы:
       - Добавить\Редактировать сообщение.
       - Вернуться на страницу списка сообщений.
   - ***message_delete.html***: страница для *удаления* Сообщения рассылки (модель данных **Message**).
     - Функционал страницы:
       - Удаление сообщения.
       - Вернуться на страницу списка сообщений.


4) `Пользовательские страницы для "Управление рассылками"`
   - ***mailing_list.html***: страница для *отображения списка* Рассылок в сервисе управления рассылками (модель данных **Mailing**).
     - Функционал страницы:
       - Переход на страницу добавления новой рассылки.
       - Переход на страницу редактирования рассылки.
       - Переход на страницу удаления рассылки.
       - Немедленный ЗАПУСК рассылки (кнопка "Запустить").
       - Планирование ЗАПУСКА на указанное время через планировщик (кнопка "Запланировать").
       - ОСТАНОВКА рассылки.
   - ***mailing_add_update.html***: страница для *добавления* новой или *обновления* существующей Рассылки (модель данных **Mailing**).
     - Функционал страницы:
       - Добавить\Редактировать рассылку.
       - Вернуться на страницу списка рассылок.
   - ***mailing_delete.html***: страница для *удаления* Рассылки (модель данных **Mailing**).
     - Функционал страницы:
       - Удаление рассылки.
       - Вернуться на страницу списка рассылок.


5) `Пользовательская страница для "Статистики"`
   - ***main.html***: главная страница для *отображения статистики* по рассылкам и получателям.

## _Приложение "users" (users/templates/):_

Реализованы следующие HTML-страницы:

1) `Пользовательская страница для начала взаимодействия с приложением`
   - ***start.html***: стартовая страница с кнопками *Войти* и *Зарегистрироваться*.


2) `Пользовательские страницы для регистрации и аутентификации пользователей`
   - ***register.html*** — страница для регистрации пользователя (кнопка *Зарегистрироваться*)
     - Функционал страницы:
       - Регистрация нового пользователя.
       - Вернуться на стартовую страницу.
   - ***email_confirmation.html*** — шаблон письма для отправки email со ссылкой для активации/завершении регистрации пользователя.
   - ***email_confirmation_sent.html*** — страница с информированием пользователя о том, что ему отправлен email со ссылкой для активации/завершении регистрации пользователя.
   - ***login.html*** — страница для аутентификации пользователя в приложении (кнопка *Войти*).
     - Функционал страницы:
       - Войти в систему.
       - Вернуться на стартовую страницу.
       - Запрос сброса пароля, если забыл.
   - ***password_reset.html*** — форма ввода email, при решении выполнить *сброс/восстановление* пароля, для последующей отправки ссылки восстановления на указанную почту.
   - ***password_reset_done.html*** — страница с информированием пользователя об отправке письма на его почту.
   - ***password_reset_confirm.html*** — форма для ввода пользователем нового пароля (пользователь открыл ссылку из письма, вводит новый пароль).
   - ***password_reset_complete.html*** — страница с информированием пользователя об успешной смене старого пароля.
   - ***email_confirm_reset.html*** — шаблон письма для отправки email со ссылкой на ввод нового пароля.


3) `Пользовательские страницы для Менеджеров сервиса`
   - ***user_list.html***: страница для отображения *списка пользователей* сервиса.
     - Функционал страницы:
       - Переход на страницу блокировки пользователей сервиса.




# <a id="title3">3. Описание моделей (models)</a>

## _Приложение "app_mailing" (app_mailing/models.py):_

1) Модель данных `Recipient(models.Model)` - представляет "Получателя рассылки" в сервисе управления рассылками.
   - ***Поля модели:***
     - Почта получателя (email).
     - Ф.И.О. получателя (full_name).
     - Комментарий (comment).
     - Владелец (owner) - внешний ключ на модель "Пользователь" (*models.ForeignKey(to=settings.AUTH_USER_MODEL)*).


2) Модель данных `Message(models.Model)` - представляет "Сообщение рассылки" в сервисе управления рассылками.
   - ***Поля модели:***
     - Тема письма (message_subject).
     - Тело письма (message_body).
     - Владелец (owner) - внешний ключ на модель "Пользователь" (*models.ForeignKey(to=settings.AUTH_USER_MODEL)*).


3) Модель данных `Mailing(models.Model)` - представляет "Рассылку" в сервисе управления рассылками.
   - ***Поля модели:***
     - Дата и время первой отправки (first_message_sending).
     - Дата и время окончания отправки (end_message_sending).
     - Статус рассылки (status):
       - Доступные варианты статусов:
         - *Создана* - рассылка была создана, но еще ни разу не была отправлена.
         - *Запущена* - рассылка активна и была отправлена хотя бы один раз.
         - *Завершена* - время окончания отправки рассылки прошло.
     - Сообщение для рассылки (message) - внешний ключ на модель "Сообщение" (*models.ForeignKey(to=Message)*).
     - Получатели для рассылки (mailing_recipients) - "многие ко многим", связь с моделью "Получатель" (*models.ManyToManyField(to=Recipient)*).
     - Владелец (owner) - внешний ключ на модель "Пользователь" (*models.ForeignKey(to=settings.AUTH_USER_MODEL)*).


4) Модель данных `Attempt(models.Model)` - представляет "Попытку рассылки" в сервисе управления рассылками.
     - Дата и время попытки рассылки (attempt_time).
     - Статус попытки рассылки (status):
       - Доступные варианты статусов:
         - *Успешно*.
         - *Не успешно*.
     - Ответ почтового сервера (server_response).
     - Рассылка (mailing) - внешний ключ на модель "Рассылка" (*models.ForeignKey(to=Mailing)*).
     - Получатель (recipient) - внешний ключ на модель "Получатель" (*models.ForeignKey(to=Recipient)*).
     - Владелец (owner) - внешний ключ на модель "Пользователь" (*models.ForeignKey(to=settings.AUTH_USER_MODEL)*).

## _Приложение "users" (users/models.py):_

1) Модель данных `AppUser(AbstractUser)` - представляет "Пользователя" в сервисе управления рассылками.
   - Наследуется от модели **AbstractUser**, которая является готовой моделью и включает все основные поля и методы, такие как username, email, first_name, last_name, is_staff, is_active и другие.
   - ***Дополнительно определил:***
     - ник (username).
     - почта (email).
     - аватар (avatar).
     - статус блокировки пользователя менеджером сервиса (is_blocked).
       - permissions = [
              ("can_see_list_user", "Может видеть список пользователей сервиса"),
              ("can_block_user", "Может блокировать пользователей сервиса"),
          ]




# <a id="title4">4. Описание админок (admin)</a>

## _Приложение "app_mailing" (app_mailing/admin.py):_

1) Админка `RecipientAdmin(admin.ModelAdmin)` - отображение данных "Получатель рассылки" в админке (модель *Recipient*).


2) Админка `MessageAdmin(admin.ModelAdmin)` - отображение данных "Сообщение рассылки" в админке (модель *Message*).


3) Админка `MailingAdmin(admin.ModelAdmin)` - отображение данных "Рассылка" в админке (модель *Mailing*).


4) Админка `AttemptAdmin(admin.ModelAdmin)` - отображение данных "Попытки рассылки" в админке (модель *Attempt*).

## _Приложение "app_mailing" (app_mailing/admin.py):_

1) Админка `AppUserAdmin(UserAdmin)` - отображения модели "Пользователя" в админке (модель *AppUser*).




# <a id="title5">5. Описание форм (forms)</a>

## _Приложение "app_mailing" (app_mailing/forms.py):_

1) `AddNewRecipientForm(forms.ModelForm)` - форма для добавления пользователем нового *Получателя рассылки* на странице **recipient_add_update.html**
   - ***Кастомизация формы***:
     - `def clean_email(self)` - метод для валидации email: проверяет, существует ли уже получатель с таким email у текущего пользователя (owner). Если да - не позволяет повторно добавить этого получателя. Это предотвращает дублирование одного и того же email в списке клиента приложения, но разрешает другим пользователям добавлять такого же получателя себе.
     - `def __init__()` - стилизации полей формы с использованием виджета. Виджеты позволяют настроить внешний вид и поведение полей формы через атрибуты. Это делается с помощью метода attrs.
       - Добавляем CSS-классы ко всем полям формы.
       - Убираем параметр 'help_text' со всех полей, чтоб этого больше не было по умолчанию на html-странице.


2) `AddNewMessageForm(forms.ModelForm)` - форма для добавления пользователем нового *Сообщения рассылки* на странице **message_add_update.html**
   - ***Кастомизация формы***:
     - `def __init__()` - стилизации полей формы с использованием виджета. Виджеты позволяют настроить внешний вид и поведение полей формы через атрибуты. Это делается с помощью метода attrs.
       - Добавляем CSS-классы ко всем полям формы.
       - Убираем параметр 'help_text' со всех полей, чтоб этого больше не было по умолчанию на html-странице.


3) `AddNewMailingForm(forms.ModelForm)` - форма для добавления пользователем новой *Рассылки* на странице **mailing_add_update.html**
   - ***Кастомизация формы***:
     - `def __init__()` - метод для:
       - ограничения queryset только объектами текущего пользователя (т.е. запрет на вывод всего подряд из БД даже того где *user != owner*).
       - стилизации полей формы с использованием виджета. Виджеты позволяют настроить внешний вид и поведение полей формы через атрибуты. Это делается с помощью метода attrs.
         - Добавляем CSS-классы ко всем полям формы.
         - Убираем параметр 'help_text' со всех полей, чтоб этого больше не было по умолчанию на html-странице.
         - Переопределяем отображение объектов в select-е, чтоб не выводился из модели текст *"Тема письма:"* в f"Тема письма: {self.message_subject}"

## _Приложение "users" (users/forms.py):_

1) `AppUserRegistrationForm(UserCreationForm)` - форма для регистрации пользователя в сервисе управления рассылками на странице **register.html**.
   - ***Кастомизация формы***:
     - `def __init__()` - стилизации полей формы с использованием виджета. Виджеты позволяют настроить внешний вид и поведение полей формы через атрибуты. Это делается с помощью метода attrs.
       - Добавляем CSS-классы ко всем полям формы.
       - Убираем параметр 'help_text' со всех полей, чтоб этого больше не было по умолчанию на html-странице.
     - `def clean_email(self)` - переопределение clean_email() для явной проверки уникальности email. Функция clean_email() нужна, даже если email уже unique=True в модели как у нас потому что unique=True в модели выбрасывает ошибку на уровне БД, но не показывает ее в форме, а clean_email() помогает показать пользователю в форме, что такой email уже занят.


2) `AppUserLoginForm(AuthenticationForm)` - форма для входа ранее зарегистрированного пользователя в сервис управления рассылками на странице **login.html**.
   - ***Кастомизация формы***:
     - `def __init__()` - стилизации полей формы с использованием виджета. Виджеты позволяют настроить внешний вид и поведение полей формы через атрибуты. Это делается с помощью метода attrs.
       - Добавляем CSS-классы ко всем полям формы.
       - Убираем параметр 'help_text' со всех полей, чтоб этого больше не было по умолчанию на html-странице.
     - `def clean(self)` - переопределение дефолтного сообщения Django об ошибке.
       - БЫЛО: **Please enter a correct Почта (username): and password. Note that both fields may be case-sensitive.**
       - СТАЛО: **Пожалуйста, проверьте правильность введённых данных и повторите попытку.**
       - В реализации использую gettext_lazy() - инструмент для поддержки многоязычности (i18n, internationalization).



    
# <a id="title6">6. Описание контроллеров (views)</a>

## _Приложение "app_mailing" (app_mailing/views.py):_

### _1. Управление клиентами_

1) Класс-контроллер `RecipientListView(LoginRequiredMixin, generic.ListView)` - представление для отображения списка *Получателей* рассылки.
   - ***Кастомизация контроллера***:
     - `def get_queryset(self)` - метод для:
       - сортировки на странице *Получателей* по ФИО (в алфавитном порядке).
       - ограничения данных по owner, т.е. выводим только те данные, где user==owner.
       - проверка является ли пользователь "Менеджером" - если пользователь входит в группу *Менеджер сервиса*, то выводим абсолютно все данные из БД.
   - ***Кэширование***:
     - используется декоратор для создания кеша для всей страницы с параметром *key_prefix*, который потом нужен для сброса кэша страницы при добавлении/редактировании/удалении данных какого-либо объекта (получателя): `@method_decorator(cache_page(60 * 15, key_prefix="recipients_list"), name="dispatch"`.


2) Класс-контроллер `RecipientCreateView(LoginRequiredMixin, generic.CreateView)` - представление для добавления нового *Получателя* рассылки.
   - ***Кастомизация контроллера***:
     - form_class = AddNewRecipientForm.
     - `def get_form_kwargs(self)` - метод для передачи в форму информации о текущем пользователе (владелец - owner), чтобы метод clean_email, который я добавил в самой форме (AddNewRecipientForm) мог корректно проверять уникальность email по владельцу. Без этого clean_email в форме (AddNewRecipientForm) не сможет определить, кому принадлежит объект.
     - `def form_valid(self, form)` - метод для:
       - отправки пользователю уведомления об успешном добавлении нового *Получателя* в список рассылки.
       - автоматического заполнение текущим пользователем поля 'owner' при создании нового *Получателя рассылки*.
       - сброса кэша при добавлении нового *Получателя*.


3) Класс-контроллер `RecipientUpdateView(LoginRequiredMixin, generic.UpdateView)` - представление для редактирования существующего *Получателя* рассылки.
   - ***Кастомизация контроллера***:
     - form_class = AddNewRecipientForm.
     - `def dispatch(self, request, *args, **kwargs)` - метод выполняет проверку прав пользователя на редактирование *Получателя рассылки* (создатель получателя), заранее до выполнения любого запроса (GET, POST и т.д.).
     - `def form_valid(self, form)` - метод для:
       - отправки пользователю уведомления об успешном редактировании данных *Получателя* из списка рассылки.
       - сброса кэша при редактировании данных какого-либо *Получателя* из списка.


4) Класс-контроллер `RecipientDeleteView(LoginRequiredMixin, generic.DeleteView)` - представление для удаления *Получателя* рассылки.
   - ***Кастомизация контроллера***:
     - `def dispatch(self, request, *args, **kwargs)` - метод выполняет проверку прав пользователя на удаление *Получателя рассылки* (создатель получателя), заранее до выполнения любого запроса (GET, POST и т.д.).
     - `def form_valid(self, form)` - метод для:
       - отправки пользователю уведомления об успешном удалении *Получателя* из списка рассылки.
       - сброса кэша при удалении какого-либо *Получателя* из списка.

### _2. Управление сообщениями_

1) Класс-контроллер `MessageListView(LoginRequiredMixin, generic.ListView)` - представление для отображения списка *Сообщений* для рассылок.
   - ***Кастомизация контроллера***:
     - `def get_queryset(self)` - метод для ограничения данных по owner, т.е. выводим только те данные, где user==owner.
   - ***Кэширование***:
     - используется декоратор для создания кеша для всей страницы с параметром key_prefix, который потом нужен для сброса кэша страницы при редактировании/изменении/удалении данных какого-либо объекта (сообщения): `@method_decorator(cache_page(60 * 15, key_prefix="messages_list"), name="dispatch"`.


2) Класс-контроллер `MessageCreateView(LoginRequiredMixin, generic.CreateView)` - представление для добавления нового *Сообщения* рассылки.
   - ***Кастомизация контроллера***:
     - form_class = AddNewMessageForm.
     - `def form_valid(self, form)` - метод для:
       - отправки пользователю уведомления об успешном добавлении нового *Сообщения* в список рассылки.
       - автоматического заполнения текущим пользователем поля 'owner' при создании нового *Сообщения рассылки*.
       - сброса кэша при добавлении нового *Сообщения*.


3) Класс-контроллер `MessageUpdateView(LoginRequiredMixin, generic.UpdateView)` - представление для редактирования существующего *Сообщения* рассылки.
   - ***Кастомизация контроллера***:
     - form_class = AddNewMessageForm.
     - `def dispatch(self, request, *args, **kwargs)` - метод выполняет проверку прав пользователя на редактирование *Сообщения рассылки* (создатель сообщения), заранее до выполнения любого запроса (GET, POST и т.д.).
     - `def form_valid(self, form)` - метод для:
       - отправки пользователю уведомления об успешном редактировании данных *Сообщения* из списка рассылки.
       - сброса кэша при обновлении данных какого-либо *Сообщения* из списка.


4) Класс-контроллер `MessageDeleteView(LoginRequiredMixin, generic.DeleteView)` - представление для удаления *Сообщения* рассылки.
   - ***Кастомизация контроллера***:
     - `def dispatch(self, request, *args, **kwargs)` - метод выполняет проверку прав пользователя на редактирование *Сообщения рассылки* (создатель сообщения), заранее до выполнения любого запроса (GET, POST и т.д.).
     - `def form_valid(self, form)` - метод для:
       - отправки пользователю уведомления об успешном удалении *Сообщения* из списка рассылки.
       - сброса кэша при удалении какого-либо *Сообщения* из списка.

### _3. Управление рассылками_

1) Класс-контроллер `MailingListView(LoginRequiredMixin, generic.ListView)` - представление для отображения списка *Рассылок*.
   - ***Кастомизация контроллера***:
     - `def get_queryset(self)` - метод для:
       - сортировки на странице *Рассылок* по их статусу: запущена → создана → завершена, внутри по дате окончания.
       - ограничения данных по owner, т.е. выводим только те данные, где user==owner.
       - проверка является ли пользователь "Менеджером" - если пользователь входит в группу 'Менеджер сервиса', то выводим абсолютно все данные из БД.
   - ***Кэширование***:
     - используется декоратор для создания кеша для всей страницы с параметром key_prefix, который потом нужен для сброса кэша страницы при добавлении/редактировании/удалении данных какого-либо объекта (рассылки): `@method_decorator(cache_page(60 * 15, key_prefix="messages_list"), name="dispatch"`.


2) Класс-контроллер `MailingCreateView(LoginRequiredMixin, generic.CreateView)` - представление для добавления новой *Рассылки*.
   - ***Кастомизация контроллера***:
     - form_class = AddNewMailingForm.
     - `def get_form_kwargs(self)` - метод для передачи request.user в форму для дальнейшего ограничения выбора доступных объектов из БД в выпадающих списках формы *AddNewMailingForm* так, чтобы пользователи видели только свои объекты.
     - `def form_valid(self, form)` - метод для:
       - отправки пользователю уведомления об успешном добавлении новой *Рассылки* в список.
       - автоматического заполнения текущим пользователем поля 'owner' при создании нового *Рассылки*.
       - сброса кэша при добавлении новой *Рассылки*.


3) Класс-контроллер `MailingUpdateView(LoginRequiredMixin, generic.UpdateView)` - представление для редактирования существующей *Рассылки*.
   - ***Кастомизация контроллера***:
     - form_class = AddNewMailingForm.
     - `def dispatch(self, request, *args, **kwargs)` - метод выполняет проверку прав пользователя на редактирование *Рассылки* (создатель рассылки), заранее до выполнения любого запроса (GET, POST и т.д.).
     - `def get_form_kwargs(self)` - метод для передачи request.user в форму для дальнейшего ограничения выбора доступных объектов из БД в выпадающих списках формы *AddNewMailingForm* так, чтобы пользователи видели только свои объекты.
     - `def form_valid(self, form)` - метод для:
       - отправки пользователю уведомления об успешном редактировании данных *Рассылки* из списка.
       - сброса кэша при редактировании данных какой-либо существующей *Рассылки*.


4) Класс-контроллер `MailingDeleteView(LoginRequiredMixin, generic.DeleteView)` - представление для удаления *Рассылки*.
   - ***Кастомизация контроллера***:
     - `def dispatch(self, request, *args, **kwargs)` - метод выполняет проверку прав пользователя на удаление *Рассылки* (создатель рассылки), заранее до выполнения любого запроса (GET, POST и т.д.).
     - `def form_valid(self, form)` - метод для:
       - отправки пользователю уведомления об успешном удалении *Рассылки* из списка.
       - сброса кэша при удалении какой-либо *Рассылки* из списка.


5) Класс-контроллер `SendMailingView(LoginRequiredMixin, generic.View)` - представление для запуска выбранной пользователем *Рассылки* вручную через интерфейс и фиксации *Попыток рассылок* по каждому *Получателю* из рассылки.
   - ***Кастомизация контроллера***:
     - `def post(self, request, pk)` - метод для:
       - запуска сервисной функции ***send_mailing()*** из *services.py*, которая:
         - отправляет email всем получателям в выбранной *Рассылке*.
         - фиксирует *Попытки рассылок* по каждому получателю.
       - сброса кэша при запуске какой-либо *Рассылки* из списка.
       - информирования пользователя об успешном запуске выбранной *Рассылки*.


6) Класс-контроллер `StopMailingView(LoginRequiredMixin, generic.View)` - представление для остановки выбранной пользователем *Рассылки* вручную через интерфейс и фиксации остановки *Попыток рассылок* по каждому *Получателю* из рассылки, которые еще не были отправлены.
   - ***Кастомизация контроллера***:
     - `def post(self, request, pk)` - метод для:
       - инициирования остановки *Рассылки*:
          - Завершает рассылку.
          - Фиксирует "неудачные" попытки рассылки по оставшимся получателям.
          - Возвращает пользователя на список рассылок.
       - сброса кэша при остановке какой-либо *Рассылки* из списка.
       - информирования пользователя об успешной остановке запущенной ранее *Рассылки*.

7) Класс-контроллер `ScheduleMailingModalView(LoginRequiredMixin, generic.View)` - представление для планирования запуска *Рассылки* через модальное окно.
   - ***Кастомизация контроллера***:
     - `def post(self, request, pk)` - метод для:
       - Устанавливает дату и время первого запуска (first_message_sending).
       - Переводит рассылку в статус "created" (готова к отправке).
       - Планировщик APScheduler обработает эту рассылку в нужный момент.
       - Выполняется проверка прав (только владелец рассылки может её планировать).
       - Очищает кеш списка рассылок для мгновенного отображения изменений.
       - Показывает пользователю уведомление об успехе или ошибке.

### _4. Главная страницы_

1) Класс-контроллер `MainPageView(LoginRequiredMixin, generic.TemplateView)` - представление для отображения *Главной страницы* со статистикой рассылок.
   - ***Кастомизация контроллера***:
     - `def get_context_data(self, **kwargs)` - метод для добавления в контекст данных для отображения на *Главной странице*:
       - ЧАСТЬ 1: Основная статистика по рассылкам из Mailing и получателям из Recipient:
         - Общее количество рассылок.
         - Количество активных рассылок (статус 'Запущена') + количество получателей именно по активным рассылкам.
         - Общее количество уникальных получателей.
       - ЧАСТЬ 2: Статистика по отправкам из Attempt:
         - Количество успешных попыток рассылок.
         - Количество неуспешных попыток рассылок.
         - Общее количество отправленных сообщений + сколько из них именно уникальных текстов сообщений.

## _Приложение "users" (users/views.py):_

### _1. Контроллеры для регистрации и аутентификации пользователей, для подтверждения своего email для входа и выхода из системы, а также для восстановления пароля_

1) Класс-контроллер `UserStartView(TemplateView)` - представление для стартовой страницы (start.html) с кнопками "Войти" и "Зарегистрироваться".
   - ***Кастомизация контроллера***:
     - `def dispatch(self, request, *args, **kwargs):` - добавлен редирект авторизованного пользователя, чтобы он, когда переходит на /start/ (например, по прямой ссылке), не попадал туда снова, а автоматически перенаправлялся на главную страницу авторизованного пользователя.


2) Класс-контроллер `UserRegisterView(FormView)` - представление для отображения страницы регистрации нового пользователя (register.html) с последующей отправкой письма для подтверждения email.
   - ***Кастомизация контроллера***:
     - form_class = AppUserRegistrationForm.
     - `def form_valid(self, form)` - метод для обработки валидной формы регистрации:
       - Если пользователь с таким email уже существует и активен - регистрация невозможна.
       - Если пользователь существует, но не активен - повторно отправляем письмо с подтверждением.
       - Если пользователь не существует - создаём нового, отправляем письмо.сохранения нового пользователя и автоматический вход после регистрации.


3) Класс-контроллер `ActivateAccountView(View)` - представление для активации учетной записи пользователя по email-ссылке.
   - ***Кастомизация контроллера***:
     - `def get(self, request, uidb64, token)` - метод для обработки GET-запроса по ссылке из email:
       - Расшифровка uid пользователя.
       - Проверка токена.
       - Активация пользователя и логинит его в приложении.
       - Перенаправление на главную страницу.


4) Класс-контроллер `UserEmailConfirmationSentView(TemplateView)` - представление для промежуточной страницы после регистрации с инструкцией по подтверждению email.
   - ***Кастомизация контроллера***:
     - `def dispatch(self, request, *args, **kwargs)` - метод для проверки авторизован ли пользователь. Если да, то он уже подтвердил email и не должен видеть эту страницу. В таком случае происходит перенаправление на главную страницу приложения. Если пользователь не авторизован, продолжается обычная обработка запроса.


5) Для `ВЫХОДА ИЗ СИСТЕМЫ` решил не выполнять кастомизацию процесса и использую стандартное поведение ***LogoutView***.
Дополнительно для редиректа после выхода из приложения используется параметр **LOGOUT_REDIRECT_URL**, который задает URL-адрес, на который будет перенаправлен пользователь после выхода.


6) Класс-контроллер `UserLoginView(LoginView)` - представление для входа пользователя (login.html).
   - ***Кастомизация контроллера***:
     - `def get_success_url(self)` - метод get_success_url() в LoginView это предпочтительный для Django способ указания редиректа после успешной аутентификации. Если просто указать в контроллере ***success_url = reverse_lazy('app_mailing:main_page')***, то это не будет работать.
     - `def form_valid(self, form)` - метод для автоматического входа пользователя после успешной аутентификации.


7) Для `ВОССТАНОВЛЕНИЯ ПАРОЛЯ` через email используются стандартные Django-классы (т.е. реализация из "коробки" без кастомизации):
- *PasswordResetView()* — класс для формы ввода email.
- *PasswordResetDoneView()* — класс для подтверждения, что письмо отправлено.
- *PasswordResetConfirmView()* — класс для установки нового пароля по ссылке.
- *PasswordResetCompleteView()* — класс для подтверждения успешной смены пароля.

### _2. Контроллеры для пользователей "Менеджер сервиса"_

1) Класс-контроллер `AppUserListView(LoginRequiredMixin, generic.ListView)` - представление для отображения списка *Пользователей сервиса*.
   - ***Кастомизация контроллера***:
     - `def dispatch(self, request, *args, **kwargs)` - метод проверяет, имеет ли текущий пользователь право 'can_see_list_user' на просмотр списка пользователей.
     Если не имеет - возвращает запрет доступа (403 Forbidden). Эта проверка выполняется до обработки любого типа запроса (GET, POST и т.д.), гарантируя безопасность доступа ко всем методам представления.


2) Класс-контроллер `BlockUserView(LoginRequiredMixin, generic.View)` - представление для блокировки *Пользователя* Менеджером сервиса.
   - ***Кастомизация контроллера***:
     - `def dispatch(self, request, *args, **kwargs)` - метод проверяет, имеет ли текущий пользователь право ***can_block_user*** на блокировку пользователей.
       - Если не имеет - возвращает запрет доступа (403 Forbidden).
       - Выполняется до обработки любого запроса, обеспечивая защиту на всех уровнях.
     - `def post(self, request, pk)` - метод инициирует ***блокировку*** пользователя и остановку активных рассылок:
        - Получает объект пользователя по ID.
        - Устанавливает ***is_blocked = True***.
        - Принудительно завершает все *Рассылки* со статусом ***launched***.
        - Каждая из *Рассылок* переводится в ***accomplished***, а оставшиеся *письма* считаются ***неудачными***.


3) Класс-контроллер `UnblockUserView(LoginRequiredMixin, generic.View)` - представление для разблокировки *Пользователя* Менеджером сервиса.
   - ***Кастомизация контроллера***:
     - `def dispatch(self, request, *args, **kwargs)` - метод проверяет, имеет ли текущий пользователь право ***can_block_user*** на разблокировку пользователей.
       - Если не имеет - возвращает запрет доступа (403 Forbidden).
       - Выполняется до обработки любого запроса, обеспечивая защиту на всех уровнях.
     - `def post(self, request, pk)` - метод инициирует ***разблокировку*** пользователя и снятие ограничений с него:
        - Получает объект пользователя по ID.
        - Устанавливает ***is_blocked = False***.




# <a id="title7">7. Ограничение прав доступа</a>

1) Защита через `LoginRequiredMixin`.
   - Цель: Ограничить доступ ко всем представлениям, связанным с рассылками, сообщениями, получателями, статистикой и т.д., только для авторизованных пользователей.
   Без авторизации любой пользователь может открыть /mailings/, /recipients/ и т.д.
   - Это базовый уровень безопасности, обязательный перед более тонкой RBAC (разграничением по ролям).




# <a id="title8">8. Менеджер команд (management/commands/)</a>

## _Приложение "app_mailing" (app_mailing/management/commands/):_

1) `send_mailing.py` - команда для запуска *Рассылки* из командной строки и фиксации *Попыток рассылок* по каждому *Получателю* из рассылки.
   - Пример команды для запуска рассылки с id=1:
   ``` commandline
   python manage.py send_mailing 1
   ```

## _Приложение "users" (users/management/commands/):_

1) `create_groups.py` - команда для создания группы *Менеджер сервиса* с правами:
   - все *view-доступы* ко всем моделям.
   - кастомные права:
     - право *can_see_list_user*.
     - право *can_block_user*.
   - Команда для запуска:
     ``` commandline
     python manage.py create_groups
     ```




# <a id="title9">9. Сервисные функции (services.py)</a>

## _Приложение "app_mailing" (app_mailing/services.py):_

1) Функция `send_mailing(request, mailing)` - сервисная функция для запуска Рассылки:
    - ***:param mailing***: объект рассылки (Mailing), которую нужно запустить.
    - Отправка email всем получателям в выбранной *Рассылке*.
    - Фиксация *Попыток рассылок* по каждому получателю.


2) Функция `send_mailing_cli(mailing)` - CLI-версия сервисной функции для запуска Рассылки:
   - ***:param mailing***: объект рассылки (Mailing), которую нужно запустить.
   - Не требует request.
   - Возвращает словарь с результатом рассылки (успешные, неудачные попытки).
   - Отправка email всем получателям в выбранной *Рассылке*.
   - Фиксация *Попыток рассылок* по каждому получателю.


3) Функция `stop_mailing(mailing, reason)` - сервисная функция для остановки Рассылки:
   - ***:param mailing***: объект рассылки (Mailing), которую нужно остановить.
   - ***:param reason***: пояснение причины остановки (сохраняется в server_response).
   - Устанавливает статус **accomplished**.
   - Фиксирует время окончания рассылки.
   - Создает **failed** попытки рассылки по тем получателям, которым еще не отправлено сообщение.
   - Используется:
     - Пользователем сервиса в контроллере StopMailingView.
     - Менеджером сервиса при блокировке пользователя.

## _Приложение "users" (users/services.py):_

1) Функция `block_user(user)` - сервисная функция для блокировки переданного пользователя, если он ещё не заблокирован:
   - Устанавливает is_blocked=True и сохраняет изменения.
   - Используется:
     - Менеджером сервиса при управлении пользователями.
     - Влечёт за собой ограничения на создание/изменение рассылок и их запуск.


2) Функция `unblock_user(user)` - сервисная функция для разблокировки переданного пользователя, если он ранее был заблокирован:
   - Устанавливает is_blocked=False и сохраняет изменения.
   - Используется:
     - Менеджером сервиса при управлении пользователями.
     - Влечёт за собой снятие ограничения на создание/изменение рассылок и их запуск.




# <a id="title10">10. Функционал рассылки по расписанию (scheduler.py)</a>

## _Приложение "app_mailing" (app_mailing/scheduler.py):_

1) Планировщик существует как глобальный объект - один на всё приложение! ПОЭТОМУ создание Планировщика и подключение
DjangoJobStore для хранения job'ов в базе данных ДОЛЖНО БЫТЬ НА УРОВНЕ МОДУЛЯ, а не внутри функции start()
mailing_scheduler = BackgroundScheduler(timezone=str(timezone.get_current_timezone()))
mailing_scheduler.add_jobstore(DjangoJobStore(), "default")


2) Функция `my_scheduled_job()` - регулярно проверяет все рассылки, которые запланированы на "сейчас или раньше" но ещё не отправлены *(status='created')* и запускает их.


3) Функция `start()` - инициализирует и запускает планировщик:
   - регистрация события.
   - добавление задачи на повторяющийся запуск.
   - сам запуск планировщика в фоновом режиме.




# <a id="title11">11. Автозапуск планировщика (apps.py)</a>

## _Приложение "app_mailing" (app_mailing/apps.py):_

В модуле *apps.py* класс `AppMailingConfig(AppConfig)` создается Django автоматически при инициализации приложения.
Данный модуль в фоновом режиме всегда запускается первым при запуске приложения (запуск сервера).

1) Добавляю новый метод в `class AppMailingConfig(AppConfig)`:
   - метод `def ready(self)` - он запускается Django при старте приложения. Здесь мы импортируем модуль scheduler.py и запускаем из него планировщик mailing_scheduler, который существует как глобальный объект (то есть на уровне модуля, а значит mailing_scheduler запустится в фоновом режиме сразу же при обращении к модулю).




# <a id="title12">12. Вспомогательные функции (managers.py)</a>

## _Приложение "users" (users/managers.py):_

1) Класс `AppUserManager(BaseUserManager)` - кастомный менеджер для пользователя без поля username:
   - функция `create_user()` - создает и возвращает обычного пользователя.
   - функция `create_superuser()` - создает и возвращает суперпользователя.




# <a id="title13">13. Установка проекта</a>

1. Клонируйте репозиторий:
   ```
   git clone https://github.com/MaksimLakovich/Coursework-4-Mailing-management-service.git
   ```
2. Установите зависимости:
   ```
   poetry install
   ```
3. Заполните файл `.env` по примеру `.env.example`




# <a id="title14">14. Получение ключей. Описание файла .env.example</a> 

1. Создайте файл .env в корне проекта из копии подготовленного файла `.env.example`, в котором описаны названия всех переменных, необходимых для работы приложения.
2. Замените значения переменных реальными данными.
3. В модуле `settings.py` существует секретный ключ `SECRET_KEY`, который рекомендуется в целях безопасности хранить в тайне:
4. Файл .env должен содержать данные:
```dotenv
# Настройки секретного ключа проекта django в config/settings.py
#Django рекомендует в целях безопасности хранить секретный ключ, используемый в продакшене, в тайне!
SECRET_KEY_FOR_PROJECT=secret_key_here

# Настройки дебага.
# В settings.py дебаг должен быть описан так: DEBUG = True if os.getenv('DEBUG') == 'True' else False
DEBUG=

# Настройки БД проекта django в config/settings.py
DATABASE_NAME=
DATABASE_USER=
DATABASE_PASSWORD=
DATABASE_HOST=
DATABASE_PORT=

# Настройка SMTP-сервера Яндекса для отправки уведомлений пользователям магазина по почте:
YANDEX_EMAIL_HOST_USER=''
YANDEX_EMAIL_HOST_PASSWORD=''

# Данные почты и устанавливаемого пароля для создания Администратора с помощью кастомной команды:
ADMIN_EMAIL=''
ADMIN_PASSWORD=''

# Данные Redis-сервера и используемого порта
REDIS_URL=
```




# <a id="title15">15. Описание файла .flake8</a> 

```ini
[flake8]
max-line-length = 119
ignore = E203, W503
exclude = .git, __pycache__, venv, .venv
```




# <a id="title16">16. Описание файла mypy.ini</a> 

```ini
[mypy]
ignore_missing_imports = True
```




# <a id="title17">17. Описание директории data/</a> 

- Папка ***data/fixtures/***:

  1) файл `add_recipients.json` - фикстура с тестовыми получателями для рассылок.
  
    Команда для загрузки данных из фикстуры:
    ```commandline
    python manage.py loaddata data/fixtures/add_recipients.json
    ```
    
  2) файл `add_messages.json` - фикстура с тестовыми сообщениями для рассылок.
  
    Команда для загрузки данных из фикстуры:
    ```commandline
    python manage.py loaddata data/fixtures/add_messages.json
    ```
    
  3)  файл `add_mailings.json` - фикстура с тестовыми рассылками.
  
    Команда для загрузки данных из фикстуры:
    ```commandline
    python manage.py loaddata data/fixtures/add_mailings.json
    ```